int upper = 1;
int others = 2;
int inner = 3;

border C01(t=0, 1){x=0; y=-1+t; label=upper;}
border C02(t=0, 1){x=1.5-1.5*t; y=-1; label=upper;}
border C03(t=0, 1){x=1.5; y=-t; label=upper;}
border C04(t=0, 1){x=1+0.5*t; y=0; label=others;}
border C05(t=0, 1){x=0.5+0.5*t; y=0; label=others;}
border C06(t=0, 1){x=0.5*t; y=0; label=others;}
border C11(t=0, 1){x=0.5; y=-0.5*t; label=inner;}
border C12(t=0, 1){x=0.5+0.5*t; y=-0.5; label=inner;}
border C13(t=0, 1){x=1; y=-0.5+0.5*t; label=inner;}

int n = 10;
plot(C01(-n) + C02(-n) + C03(-n) + C04(-n) + C05(-n)
  + C06(-n) + C11(n) + C12(n) + C13(n), wait=true);

mesh Th1 = buildmesh(C01(-n) + C02(-n) + C03(-n) + C04(-n) + C05(-n)
  + C06(-n) + C11(n) + C12(n) + C13(n));
mesh Th2 = buildmesh(C01(-n) + C02(-n) + C03(-n) + C04(-n) + C05(-n)
  + C06(-n) + C11(-n) + C12(-n) + C13(-n));

plot(Th1, wait=true);
plot(Th2, wait=true);

//cout << "Part 1 has region number " << Th(0.75, -0.25).region << endl;
//cout << "Part 2 has redion number " << Th(0.25, -0.25).region << endl;

border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
border b(t=0, 2*pi){x=0.3+0.3*cos(t); y=0.3*sin(t); label=2;}
plot(a(50) + b(30), wait=true); //to see a plot of the border mesh
mesh Thwithouthole = buildmesh(a(50) + b(30));
mesh Thwithhole = buildmesh(a(50) + b(-30));
plot(Thwithouthole, wait=true, ps="Thwithouthole.eps");
plot(Thwithhole, wait=true, ps="Thwithhole.eps");

{
    border a(t=0, 2*pi){x=cos(t); y=sin(t); label=1;}
    mesh Th = buildmesh(a(20));
    Th = emptymesh(Th);
    plot(Th);
}

verbosity = 4;

// Parameters
real coef = 1;

// Mesh
border aa(t=0, 1){x=t; y=0; label=1;};
border bb(t=0, 0.5){x=1; y=t; label=1;};
border cc(t=0, 0.5){x=1-t; y=0.5; label=1;};
border d(t=0.5, 1){x=0.5; y=t; label=1;};
border e(t=0.5, 1){x=1-t; y=1; label=1;};
border f(t=0, 1){x=0; y=1-t; label=1;};
mesh Th = buildmesh(aa(6) + bb(4) + cc(4) + d(4) + e(4) + f(6));
plot(Th, wait=true, fill=true, ps="Lshape.eps");

// Function
func uu = sin(y*pi)/10;
func vv = cos(x*pi)/10;

// Checkmovemesh
real minT0 = checkmovemesh(Th, [x, y]); //return the min triangle area
while(1){ // find a correct move mesh
    real minT = checkmovemesh(Th, [x+coef*uu, y+coef*vv]);
    if (minT > minT0/5) break; //if big enough
    coef /= 1.5;
}

// Movemesh
Th = movemesh(Th, [x+coef*uu, y+coef*vv]);
plot(Th, wait=true, fill=true, ps="MovedMesh.eps");
